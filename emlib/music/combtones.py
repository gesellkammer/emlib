from collections import namedtuple as _namedtuple
from emlib.containers import RecordList 
from emlib.pitchtools import f2n, n2f, m2n, n2m, f2m, m2f, interval2ratio
from emlib import lib
from emlib.iterlib import flatten, product
from itertools import combinations
from emlib.music.core import Note, Chord, asNote, ChordSeq
from emlib import typehints as t
import warnings

# ------------------------------------------------------------
#     COMBINATION TONES
# ------------------------------------------------------------

    
_Pitch = t.U[str, float, Note]


def _ringmod2f(f1: float, f2: float) -> t.Tup[float, float]:
    """
    Calculate the difference and combination freqs. between f1 and f2
    """
    comb = f1+f2
    diff = max(9, abs(f1-f2))
    return diff, comb


def _asmidi(x: _Pitch) -> float:
    """
    Converts a Note or a notename to a midinote. 
    """
    if isinstance(x, Note):
        return x.midi
    elif isinstance(x, (int, float)):
        if x > 127:
            raise ValueError("A midinote expected (< 128), but got a value of {x}!")
        return x
    elif isinstance(x, str):
        return n2m(x)
    raise TypeError(f"Expected a Note, a notename or a midinote, got {x}")


def _parsePitches(*pitches):
    midis = []
    for p in pitches:
        if isinstance(p, str):
            midis.extend(map(n2m, p.split()))
        elif isinstance(p, (Note, int, float)):
            midis.append(_asmidi(p))
        elif isinstance(p, (list, tuple)):
            midis.extend(_parsePitches(*p))
        else:
            raise TypeError(p)
    return midis


def ringmod(*pitches):
    # type: (*_Pitch) -> t.List[Note]
    """
    Calculate the ring-modulation between the given notes

    pitches:
        a midinote, a notename or a Note (no frequencies!)
        Many notenames can be given as one string, separated by spaces

    Returns the notes of the sidebands, as Notes
    """
    midis = _parsePitches(*pitches)
    freqs = list(map(m2f, midis))
    sidebands = [_ringmod2f(f1, f2) for f1, f2 in combinations(freqs, 2)]
    sidebands = list(set(flatten(sidebands)))
    sidebands.sort()
    return [Note(f2m(sideband)) for sideband in sidebands]


def sumtones(*pitches):
    # type: (*_Pitch) -> t.List[Note]
    """
    Calculate the summation tones generated by all the pair combinations of notes
    
    pitches: a seq. of Notes
    notes: a seq of notes as strings "C4", "C5+", etc. or frequencies.
    """
    midis = _parsePitches(pitches)
    freqs = list(map(m2f, midis))
    return [Note(f2m(f1+f2)) for f1, f2 in combinations(freqs, 2)]
    

class Difftone:  
    _fields = ("note0", "note1", "freq0", "freq1", "diff", "freq", "desired", "beating")

    def __init__(self, note0, note1, desired=None):
        self.note0 = n0 = asNote(note0)
        self.note1 = n1 = asNote(note1)
        self.freq0 = round(n0.freq)
        self.freq1 = round(n1.freq)
        self.diff = Note(f2m(abs(n0.freq - n1.freq)))
        self.desired = asNote(desired) if desired is not None else self.diff 
        self.beatings = round(abs(self.desired.freq - self.diff.freq))
        self._notes = None

    @property
    def notes(self):
        if self._notes is None:
            self._notes = Chord(self.note0, self.note1)
        return self._notes

    def __iter__(self):
        # these correspond to _fields
        return iter((self.note0, self.note1, self.freq0, self.freq1, self.diff,
                     round(self.diff.freq), self.desired, self.beatings))

    def __repr__(self):
        if self.desired == self.diff:
            return f"Difftone(note0={self.note0}, note1={self.note1}, diff={self.diff})"
        return f"Difftone(note0={self.note0}, note1={self.note1}, diff={self.diff}, desired={self.desired}, beatings={self.beatings})"
        
    def transpose(self, interval):
        note0 = self.note0 + interval
        note1 = self.note1 + interval 
        return Difftone(note0, note1)

    def asChord(self, diff=True):
        """
        diff: if True, the resulting difftone is included in the chord
        """
        if diff:
            ch = Chord(self.note0, self.note1, self.diff)
        else:
            ch = Chord(self.note0, self.note1)
        return ch

    def show(self):
        ch = self.asChord(diff=True)
        ch.show()

    def play(self, *args, **kws):
        return self.asChord(diff=False).play(*args, **kws)

    def shiftRatio(self, result):
        """
        Find a ratio r to multiply the freq. of the sources of this difftone so
        that they produce a difftone `result`

        NB: if note1 and note2 produce a difftone d, when note1 and note2
            both are transposed by the same interval i, the resulting 
            difftone is also transposed by the same interval i

        Example

        d = difftone_source("A3", interval=1)
        """
        return interval2ratio(self.diff.midi - _asmidi(result))


def difftones(*pitches):
    # type: (*_Pitch) -> t.List[Note]
    """
    Calculate the difference tones generated by all the pair
    combinations of notes
    
    SEE ALSO: difftones_sources, difftone_sources_in_range
    """
    midis = _parsePitches(*pitches)
    freqs = [m2f(m) for m in midis]
    return [Note(f2m(abs(f2 - f1))) for f1, f2 in combinations(freqs, 2)]
    

def difftones_cubic(*notes):
    # type: (*_Pitch) -> t.List[Note]
    """
    Return the cubic difference tones
    
    if f1 and f2 are pure tones and f1 < f2, the cubic diff-tone is
    
    2*f1 - f2
    """
    freqs = [m2f(_asmidi(note)) for note in notes]
    out = []
    for f1, f2 in combinations(freqs, 2):
        if f2 < f1:
            f1, f2 = f2, f1
        f0 = f1*2 - f2
        out.append(Note(f2m(f0)))
    return out


def difftone_source(difftone:_Pitch, interval:float, resolution=0.0) -> Difftone:
    # type: (_Pitch, float, float) -> Difftone
    """
    difftone: the resulting difftone
    interval: the interval between the two notes which should produce a 
        difference tone close to `difftone`
    resolution: the resolution of the pitch grid for the source notes. This
        also defines the acceptable error of the resulting difftone

    Returns: a Difftone
    """
    diffFreq = m2f(_asmidi(difftone))
    ratio = interval2ratio(interval)
    f0 = diffFreq / (ratio - 1)
    f1 = f0 * ratio
    midi0, midi1 = f2m(f0), f2m(f1)
    if resolution > 0:
        midi0 = lib.snap_to_grid(midi0, resolution)
        midi1 = lib.snap_to_grid(midi1, resolution)
    return Difftone(midi0, midi1, difftone)


def difftone_sources_in_range(difftone, minnote=None, maxnote="D8", resolution=0.5, maxinterval=7):
    # type: (_Pitch, t.Opt[_Pitch], _Pitch, float, float) -> t.List[Difftone]
    """
    Find all pairs of notes which produce a difference tone close to difftone (max. distance is 
    the same as the resolution) within the given range

    difftone: the resulting difftone
    minnote, maxnote: define the range within which to search for two notes which would 
        produce a difference tone near to `difftone`. If these are not given, 
        as sensible default is used
    resolution: the resolution of the pitch grid for the sources of the difftone
    maxinterval: a max. interval between the two notes of the Difftone

    returns: a list of Difftones
    """
    import warnings
    warnings.warn("Deprecrated! Use difftone_sources")
    diffmidi = _asmidi(difftone)
    if minnote is None:
        minnote = diffmidi + 13
    intervals = list(lib.frange(resolution, maxinterval, resolution))
    difftones = [difftone_source(diffmidi, interval, resolution) for interval in intervals]
    minmidi = _asmidi(minnote)
    maxmidi = _asmidi(maxnote)
    sources = [difftone for difftone in difftones
               if minmidi <= difftone.note0.midi and difftone.note1.midi <= maxmidi]
    return RecordList(sources)


def _difftone_find_source(pitch, maxdist=0.5, intervals=None,
                          minnote='A0', maxnote='C8', sumtonegap=0, resolution=1):
    pitch = _asmidi(pitch)
    pitchfreq = m2f(pitch)
    intervals = intervals or list(lib.frange(resolution, 8, resolution))
    f0 = m2f(pitch - maxdist)
    f1 = m2f(pitch + maxdist)
    minmidi = _asmidi(minnote)
    maxmidi = _asmidi(maxnote)
    out = []
    for interval in intervals:
        for m0 in lib.frange(minmidi, maxmidi+resolution, resolution):
            m1 = m0 + interval
            diffFreq = abs(m2f(m0) - m2f(m1))
            if diffFreq > f1:
                break
            elif f0 <= diffFreq <= f1:
                out.append((abs(diffFreq - pitchfreq), (m0, m1)))
    if out:
        out.sort()
        out = [pair for error, pair in out]
        out.sort()
    return out


def _difftone_find_source2(pitch, maxdist=0.5, intervals:t.List=None, minnote='A0', maxnote='C8',
                           sumtonegap=0, resolution=1):
    # type: (t.U[str, float], float, t.List[int], str, str, float) -> t.List[t.Tup[float, float]]
    """
    pitch (notename or midinote):
        The resulting pitch generated as a difftone
    maxdist:
        the max. distance between the given note and the produced difftone
    intervals:
        allowed intervals for the source pitches
    minnote, maxnote:
        the range to look for difftones
    sumtonegap:
        the minimal distance to the corresponding sumtone
    resolution:
        the resolution of the pitch grid (in semitones). 1 will search among
        all semitones betweeen minnote and maxnote, 0.5 will search all quarter-tones, etc.

    Returns: a list of pairs (note1:str, note2:str) representing notes which produce
             the given pitch as a difference tone
             (or an empty list if no pairs are found)
    """
    intervals = intervals or [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    m0 = _asmidi(pitch)
    n0 = lib.snap_to_grid(_asmidi(minnote), resolution)
    n1 = lib.snap_to_grid(_asmidi(maxnote), resolution)
    minValidFreq = 1
    results = []
    for interval in intervals:
        for midi1 in lib.frange(n0, n1-interval, resolution):
            midi2 = midi1 + interval
            f1 = m2f(midi1)
            f2 = m2f(midi2)
            diffFreq = abs(f1 - f2)
            if diffFreq <= minValidFreq:
                continue
            diffMidi = f2m(diffFreq)
            midierror = abs(diffMidi - m0)
            sumFreq = f1 + f2
            if midierror <= maxdist and (f2m(sumFreq) - diffMidi > sumtonegap):
                results.append((midierror, (midi1, midi2)))
    if not results:
        return []
    results.sort()  # secondary sort by minimal difference
    pairs = list(set(midipair for dif, midipair in results))
    pairs.sort()  # primary sort by pitch
    return pairs
    

def _sumtone_find_source(pitch, maxdist=0.5, intervals:t.List=None,
                         minnote='A0', maxnote='C8', difftonegap=0):
    # type: (t.U[str, float], float, t.List[t.U[float, int]], str, str, float) -> t.List[t.Tup[str, str]]
    """
    pitch: a note str or a midinote
    maxdist: the max. distance between the given note and #
                 the produced sumtone
    intervals: allowed intervals for the source pitches
    minnote, maxnote: the range to look for sumtones

    Returns: a list of pairs (note1:str, note2:str) representing
             notes which produce
             the given pitch as a sumtone
             (or an empty list if no pairs are found)
    """
    intervals = intervals or [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    m0 = _asmidi(pitch)
    midimin = int(n2m(minnote)) if isinstance(minnote, str) else int(minnote)
    midimax = int(n2m(maxnote)) if isinstance(maxnote, str) else int(maxnote)
    minValidFreq = 1
    results = []
    for interval in intervals:
        for midi1 in range(midimin, midimax):
            midi2 = midi1 + interval
            if midi2 > midimax:
                continue
            sumFreq = m2f(midi1) + m2f(midi2)
            if sumFreq <= minValidFreq:
                continue
            diffFreq = abs(m2f(midi1) - m2f(midi2))
            if diffFreq < 20 or (abs(f2m(diffFreq) - f2m(sumFreq)) < difftonegap):
                continue
            midiError = abs(f2m(sumFreq) - m0)
            if midiError <= maxdist:
                results.append((midiError, (midi1, midi2)))
    if not results:
        return []
    results.sort()  # secondary sort by minimal difference
    pairs = list(set(midipair for diff, midipair in results))
    pairs.sort()  # primary sort by pitch
    out = [(m2n(m1), m2n(m2)) for m1, m2 in pairs]
    assert all(isinstance(n0, str) and isinstance(n1, str) for n0, n1 in out)
    return out


def difftone_sources(result: _Pitch,
                     maxdist=0.5,
                     gap=13.0,
                     minnote=None,
                     maxnote="C8",
                     intervals=None,
                     sumtonegap=0.0,
                     resolution=1,
                     display=False
                     ) -> RecordList:
    """
    find two notes which produce a difference tone near the given note
    
    result: 
        the resulting difference tone, as Note, notename or midinote
    maxdist: 
        the maximum distance between the expected result and the generated tone,
        in semitones (0.5 == 50 cents)
    gap: 
        the distance between the resulting difference tone and the lowest of 
        the two originating notes
    intervals: 
        accepted intervals between the notes. If None is given, a set of intervals
        based on resolution is used
    resolution: 
        the resolution of the pitch grid, in semitones. A resolution of 1 will 
        search for the given difftone along all semitones between minnote and 
        maxnote

    Returns a List of Difftones
    """
    midiresult = _asmidi(result)
    maxnote = _asmidi(maxnote)
    minnote = minnote or midiresult + gap
    intervals = intervals or list(lib.frange(resolution, 7, resolution))
    pairs = _difftone_find_source(result, maxdist, minnote=minnote,
                                  maxnote=maxnote, intervals=intervals,
                                  sumtonegap=sumtonegap, resolution=resolution)
    difftones = [Difftone(note0=Note(midi0), note1=Note(midi1), desired=Note(midiresult))
                 for midi0, midi1 in pairs]
    reclist = RecordList(difftones)
    if display:
        # ipython?
        chordseq = ChordSeq([Chord(diff.note0, diff.note1, diff.diff) for diff in difftones])
        if lib.inside_jupyter():
            chordseq.show(split=midiresult+5)
            disp = _get_jupyter_display()
            disp(reclist)
        else:
            chordseq.show()
            print(reclist)
    return reclist


def _get_jupyter_display():
    if not lib.inside_jupyter():
        return None
    from IPython.display import display
    return display
    

def ringmod_exactsource(sideband1, sideband2):
    # type: (t.U[str, Number], t.U[str, Number]) -> t.Tup[Note, Note]
    """
    Find a pair of frequencies which, when ringmodulated, result in the
    given sidebands

    sideband1, sideband2: the sidebands produced, as notename or midinote

    Returns: the original pitches, as midinotes
    """
    diffFreq = m2f(_asmidi(sideband1))
    sumFreq = m2f(_asmidi(sideband2))
    f1 = (diffFreq + sumFreq)/2.0
    f0 = sumFreq - f1
    return Note(f2m(f0)), Note(f2m(f1))
    

def ringmod_sources2(sideband1, sideband2, minnote="A0", maxnote="C8", maxdiff=0.5):
    # type: (_Pitch, _Pitch, _Pitch, _Pitch, float) -> t.List[Note]
    """
    Find all pairs of two frequencies which produce the given sidebands when ringmodulated
    Returns a list of Notes

    minnote, maxnote: the range for possible answers
    maxdiff: the max. difference between the given sidebands and the resulting sidebands,
             in midi (1=semitone)
    """
    difm = _asmidi(sideband1)
    summ = _asmidi(sideband2)
    midimin = n2m(minnote) if isinstance(minnote, str) else minnote
    midimax = n2m(maxnote) if isinstance(maxnote, str) else maxnote
    results = []
    for midi1, midi2 in combinations(range(midimin, midimax), 2):
        f0, f1 = ringmod_exactsource(m2f(midi1), m2f(midi2))
        if abs(f2m(f0+f1) - summ) <= maxdiff and abs(f2m(abs(f1-f0)) - difm) <= maxdiff:
            results.append((f0, f1))
    results.sort()
    return [Note(f2m(f)) for f in results]
    

def _matchone(orig, new, maxdiff):
    """
    match at most one item from new with one item from orig

    orig, new and maxdiff should all have the same unit (freq, midi, etc)
    """
    mindiffs = {}
    matches = {}
    for o, n in product(orig, new):
        diff = abs(o-n)
        if diff < maxdiff and diff < mindiffs.get(o, float('inf')):
            mindiffs[o] = diff
            matches[o] = n
    if not matches:
        return []
    return matches.items()


def ringmod_sources(sidebands: _Pitch, 
                    minnote="A0", 
                    maxnote="C8", 
                    maxdiff=0.5,
                    matchall=True, 
                    constraints=None, 
                    numsources=None) -> t.List[Note]:
    """
    Given a seq. of sidebands, find notes that, when ringmodulated together,
    include these sidebands as the result.

    sidebands: a seq. of sidebands, as notenames or frequencies
    minnote, maxnote: limit the possible range of the sourcefreqs
    matchall: if True, all sidebands should be matched
    constraints: if given, a seq. of functions. Each of these constraints is of
                 the form (midisources, sidebands) -> bool
                 where: midisources: the sources being modulated (as midinotes)
                        sidebands: the sidebands generated (as midinote)
    Example:

    find a seq. of frequencies which generate the folowing sidebands, given that
    all sidebands should lie within the interval C2-C6

    sidebands = ["C4", "E4", "B5"]
    constraints = [lambda freqs: all(n2f("C2") <= freq <= n2f("C6") for freq in freqs)]
    sourcefreqs = ringmod_sources(sidebands, matchall=True, constraints=constraints)
    print(map(f2n, sourcefreqs))
    --> ['2C#', '4E', '5E']
    newsidebands = ringmod(*sourcefreqs)
    print(map(f2n, newsidebands))
    --> ['4C-09', '4E', '4G+30', '5D+08', '5Gb-27', '5B+02']
    """
    assert isinstance(sidebands, (list, tuple))
    sidemidis = [_asmidi(sb) for sb in sidebands]
    midi0, midi1 = n2m(minnote), n2m(maxnote)
    if len(sidebands) == 2 and (numsources == 2 or numsources is None):
        return ringmod_exactsource(sidebands[0], sidebands[1])
    elif len(sidebands) > 6 or numsources is not None and numsources > 3:
        raise NotImplementedError("too many sidebands...")
    bestmatch = []
    sourcefreqs = None
    for m0, m1, m2 in combinations(range(midi0, midi1), 3):
        freqs = list(map(m2f, (m0, m1, m2)))
        newbands = ringmod(*freqs)
        newmidis = list(map(f2m, newbands))
        matching = _matchone(sidemidis, newmidis, maxdiff)
        if not matching:
            continue
        elif matchall and len(matching) < len(sidebands):
            continue
        elif constraints and not all(constr([m0, m1, m2], newmidis)
                                     for constr in constraints):
            continue
        if len(matching) > len(bestmatch):
            bestmatch = matching
            sourcefreqs = freqs
        elif len(matching) == len(bestmatch):
            newdiff = sum(abs(orig-new) for orig, new in matching)
            lastdiff = sum(abs(orig-last) for orig, last in bestmatch)
            if newdiff < lastdiff:
                sourcefreqs = freqs
                bestmatch = matching
    return [Note(f2m(freq)) for freq in sourcefreqs]
    
        
SumTone = _namedtuple("SumTone", "notes sumnote sumfreq error")


def sumtones_sources(result, maxdist=0.5, gap=13, maxnote="C8",
                     intervals=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                     show=False, minnote="A0", difftonegap=0):
    """
    find two notes which produce a sumation tone near the given note
    
    result      : the resulting difference tone, as note
    maxdist : the maximum distance between the expected result and the generated tone,
                  in semitones (0.5 == 50 cents)
    gap         : the distance between the resulting difference tone and the highest of
                  the two originating notes
    intervals   : accepted intervals between the notes.
                  Only 'tempered' notes are used, but of course microtones produce also
                  difference tones!
    difftonegap : minimum gap (absolute value) between the sumtone and the difftone
                  produced by the two notes

    show: either False or one of:
        'report': produce a text report
        'plot': NOT IMPLEMENTED
        'musicxml': convert to musicxml, show as Finale file
        'lily': convert to lilypond, show as PDF
        'midi': convert to midifile
    """
    result = _asmidi(result)
    maxnote = _asmidi(maxnote)
    pairs = _sumtone_find_source(result, maxdist, minnote=minnote, maxnote=maxnote,
                                 intervals=intervals, difftonegap=difftonegap)
    if not pairs:
        if show == 'report':
            warnings.warn("No source pair of notes found that satisfy the given conditions")
        return []
    out = []
    resultfreq = m2f(result)
    for note0, note1 in pairs:
        sumfreq = n2f(note0) + n2f(note1)
        sumtone = SumTone((note0, note1), f2n(sumfreq), sumfreq, abs(sumfreq-resultfreq))
        out.append(sumtone)
    if show == 'report':
        raise NotImplementedError()
        # _sumtones_sources_report(result, out)
    elif show:
        from music21 import stream
        s = stream.Stream()
        for pair in out:
            notes = []
            notes.extend(pair.notes)
            notes.append(pair.result)
            label = 'diff: %.2f' % pair.diffFreq
            ch = Chord(notes).m21
            ch.lyric = label
            s.append(ch)
        if isinstance(show, str):
            s.show(show)
        else:
            s.show()
    return RecordList(out)


def wave_overtone_relative_amplitude(wavetype="saw", overtone=2):
    # type: (str, int) -> float
    """
    Return the relative amplitude of the overtone given the wavetype

    Available wavetypes are: saw, sine, square, and tri (triangle)
    """
    if overtone <= 0:
        raise ValueError("Overtone should be >= 1 (f0 = overtone 1)")
    if wavetype == "saw":
        return 1/overtone 
    elif wavetype == "square":
        return 1 / overtone * (overtone % 2)
    elif wavetype == "sine":
        return 1 if overtone == 1 else 0
    elif wavetype == "tri":
        return 1 / (overtone**2) * (overtone % 2)
    else:
        raise KeyError("wavetype not known, should be one of saw, square, sine or tri")
    

# #------------------------------------------------------------
# #
# #    estimate beatings
# #
# #------------------------------------------------------------


class DifftoneBeating(
        _namedtuple("_DifftoneBeating",
                    "beatings note1 note2 freq1, freq2, relamp")):
    def __repr__(self):
        return "Beatings: %.2f   between overtone %d (%s)" \
               "and overtone %d (%s) -- relamp: %.3f" % \
               (self.beatings, int(self.note1.freq / self.freq1 + 0.5), self.note1.name, 
                int(self.note2.freq / self.freq2 + 0.5), self.note2.name, self.relamp)


def difftones_beatings(pitch1, pitch2, maxbeatings=20, minbeatings=0.3, wave="saw",
                       report=True):
    # type: (str, str, float, float, str, bool) -> t.List[DifftoneBeating]
    """
    estimate the beatings generated by the difference tone(s) between note1 and note2
    
    for each pair of notes other than sinus-tones, many difference tones are generated:
       * between the fundamentals
       * between the overtones
    
    The calculation is based on the relative amplitude of the overtones and presuposes
    simple waveforms. Any other routine would have to work with the actual sample data
    to calculate the beatings.
    
    Using saw waves gives a sort of upper limit to the beatings which can be generated
    between two notes. In reality, the amplitude of the beatings will always be less than
    what is reported here.
    """
    defaultwave = wave
    freq1 = m2f(_asmidi(pitch1))
    freq2 = m2f(_asmidi(pitch2))
    overtones1 = [freq1 * i for i in range(1, 7)]
    overtones2 = [freq2 * i for i in range(1, 7)]
    pairs = []
    for i, o1 in enumerate(overtones1):
        for j, o2 in enumerate(overtones2):
            if minbeatings <= abs(o1 - o2) <= maxbeatings:
                amp1 = wave_overtone_relative_amplitude(defaultwave, i)
                amp2 = wave_overtone_relative_amplitude(defaultwave, j)
                amp = amp1 * amp2
                if amp > 0:
                    pairs.append((amp, o1, o2))
    pairs.sort(reverse=True)
    pairs2 = [DifftoneBeating(abs(o1-o2), Note(f2m(o1)), Note(f2m(o2)), freq1, freq2, amp)
              for amp, o1, o2 in pairs]
    return pairs2


def fm_sidebands(carrierfreq, modfreq, index, minamp=0.01, minfreq=0, maxfreq=0):
    # type: (float, float, int, float) -> t.List[t.Tup[float, float]]
    """
    Returns a list of bands which have the minimum relative amp `minamp`
    at the given modulation index
    """
    # calcular las amplitudes con scipy.special.jv(n, index),
    # donde n es el indice de la banda
    from scipy.special import jv
    bands = []
    for n in range(0, 200):
        freq0 = carrierfreq + modfreq*n
        amp = abs(jv(n, index))
        freq1 = abs(carrierfreq - modfreq*n)
        if amp > minamp:
            bands.append((freq0, amp))
            if freq1 != freq0 and freq1 > 0:
                bands.append((freq1, amp))
    bands.sort()
    if minfreq > 0 or maxfreq > 0:
        maxfreq = maxfreq if maxfreq > 0 else 24000
        bands = [band for band in bands if minfreq <= band[0] < maxfreq]
    return bands


def _checkpitch(p):
    if isinstance(p, str):
        return True
    if isinstance(p, (int, float)):
        if p > 127:
            raise ValueError(f"Expected a pitch (a notename or a midinote) but got {p}")
    raise TypeError(f"Expected a str or a float, but got {type(p)}")


def fm_chord(carrierfreq: float, modfreq: float, index: float, minamp=0.01,
             minpitch=None, maxpitch=None) -> Chord:
    maxfreq = 24000 if maxpitch is None else asNote(maxpitch).freq
    minfreq = 0 if minpitch is None else asNote(minpitch).freq
    bands = fm_sidebands(carrierfreq=carrierfreq, modfreq=modfreq, index=index,
                         minamp=minamp, minfreq=minfreq, maxfreq=maxfreq)
    notes = [Note(f2m(freq), amp=amp) for freq, amp in bands]
    return Chord(notes)
    

def fm_chord_ratio(carrier: _Pitch, ratio: float, index: float, minamp=0.01,
                   minpitch=None, maxpitch=None) -> Chord:
    carrierfreq = asNote(carrier).freq
    modfreq = carrierfreq * ratio
    return fm_chord(carrierfreq=carrierfreq, modfreq=modfreq, index=index,
                    minamp=minamp, minpitch=minpitch, maxpitch=maxpitch)
